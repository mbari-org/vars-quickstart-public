#!/usr/bin/env bash

# Brian Schlining
# 2025-12-10

set -e

# -- GLOBAL VARIABLES
# Base directory of the script
BASE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Script Name (renamed from PROG to SCRIPT_NAME for consistency)
SCRIPT_NAME=$(basename "$0")

# docker directory
DOCKER_DIR="$BASE_DIR/docker"

# Path to the etc/env directory
ETC_ENV_DIR="$BASE_DIR/etc/env"

# Path to the env file. 
ENV_FILE="$DOCKER_DIR/env.sh"

# Path to the core env file
CORE_ENV_FILE="$BASE_DIR/etc/env/core.env.sh"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored message
print_info() {
    echo -e "${BLUE}[INFO] ${NC} $1"
}

print_success() {
    echo -e "${GREEN}[OK]   ${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARN]  ${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# -- HELPER FUNCTIONS
_help() {
    cat << EOF
VARS Quickstart (varsq) - Docker orchestration for VARS services and databases

Usage: $SCRIPT_NAME <target> <subcommand> [options]

Commands:
    build     Build the docker containers
    configure Set environment variables for the target
    docker    Run docker compose commands (pass through)
    env       Show environment variables for the target
    mkcert    Generate self-signed SSL certificate and key
    resolved  Show resolved environment variables (evaluated values)
    run       Run a python or scala script
    scripts   List available python and scala scripts
    start     Start the docker containers
    stop      Stop the docker containers
    status    Show the status of the docker containers
    targets   List available targets enviroments
    update    Update the docker images

Examples:
    $(basename "$0") targets
    $(basename "$0") configure localhost
    $(basename "$0") mkcert
    $(basename "$0") start
    $(basename "$0") docker ps

EOF
}

# Load environment
load_env() {
    if [[ ! -f "$ENV_FILE" ]]; then
        print_error "No environment configured. Run: $(basename "$0") configure <target>"
        exit 1
    fi

    set -a
    source "$ENV_FILE"
    set +a
}


_build() {
    load_env
    echo "Building service using docker compose..."
    _docker build "$@"
}

_configure() {

    local target="$1"

    if [[ -z "$target" ]]; then
        print_error "No target specified"
        echo ""
        list_targets
        exit 1
    fi

    local source_file="${ETC_ENV_DIR}/${target}.env"

    if [[ ! -f "$source_file" ]]; then
        print_error "Target file not found: $source_file"
        echo ""
        list_targets
        exit 1
    fi

    if [[ ! -f "$CORE_ENV_FILE" ]]; then
        print_error "Core file not found: $CORE_ENV_FILE"
        exit 1
    fi

    print_info "Configuring environment for target: $target"

    # Merge: source file first, then core (core wins due to later exports)
    cat "$source_file" > "$ENV_FILE"
    echo "" >> "$ENV_FILE" # Add a newline for readability
    echo "# --- Core overrides (from core.env.sh) ---" >> "$ENV_FILE"
    cat "$CORE_ENV_FILE" >> "$ENV_FILE"

    print_success "Environment configured: $ENV_FILE"
}

_docker() {
    load_env   
    if [ ! -d "$DOCKER_DIR" ]; then
        print_error "Docker directory not found at '$DOCKER_DIR'." >&2
        return 1
    fi

    # TODO: Check that SSL certificates exist if needed

    print_info "Executing 'docker compose $*' inside $DOCKER_DIR/"
    # Run docker compose in a subshell, passing all arguments provided to _docker
    (cd "$DOCKER_DIR" && docker compose "$@")
}

_env() {
    echo "--- Contents of $ENV_FILE ---"
    if [ -f "$ENV_FILE" ]; then
        cat "$ENV_FILE"
    else
        print_error "$ENV_FILE not found. Run the 'configure' command first." >&2
        return 1
    fi
    echo "--------------------------------"
}


_mkcert() {
    load_env

    local cert_path="${BASE_DIR}/temp/ssl/server.crt"
    local key_path="${BASE_DIR}/temp/ssl/server.key"
    mkdir -p "$(dirname "$cert_path")"

    # if mkcert is installed, use it
    if command -v mkcert >/dev/null 2>&1; then
        print_info "mkcert found. Generating local CA and self-signed certificate..."
        # mkcert -install
        mkcert -cert-file "$cert_path" -key-file "$key_path" "localhost" "*.localhost" "127.0.0.1" "::1" "$VARS_WEB_SERVER"
        
        return
    fi
    # Fallback to openssl if mkcert is not available
    print_warning "mkcert not found. Falling back to openssl..."

    print_info "Generating self-signed SSL certificate at '$cert_path' and key at '$key_path'..."

    # Determine if VARS_WEB_SERVER is an IP address or a hostname
    local san_entry
    if [[ "$VARS_WEB_SERVER" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || [[ "$VARS_WEB_SERVER" =~ : ]]; then
        san_entry="IP:${VARS_WEB_SERVER}"
    else
        san_entry="DNS:${VARS_WEB_SERVER}"
    fi

    openssl req -x509 -nodes -days 3650 -newkey rsa:2048 \
        -keyout "$key_path" \
        -out "$cert_path" \
        -subj "/C=US/ST=California/L=Monterey/O=MBARI/OU=IT/CN=localhost" \
        -addext "subjectAltName=DNS:localhost,DNS:*.local,${san_entry},IP:127.0.0.1"

    print_success "Self-signed SSL certificate and key generated successfully."
}

_resolved() {
    load_env
    print_info "Resolved environment variables from $ENV_FILE"
    echo "# ------------------------------------------------------"
    # Source the env file in a subshell and print all exported variables with their resolved values
    (
        # shellcheck source=/dev/null
        source "$ENV_FILE"
        # Use env to get all environment variables, filter for those starting with common prefixes
        # Sort for easier reading
        env | grep -E '^(ANNOSAURUS_|BEHOLDER_|CHARYBDIS_|ONI_|PANOPTES_|RAZIEL_|SKIMMER_|VAMPIRESQUID_|VAMPIRE_SQUID_|VARS_|M3_|LOGBACK_|BASICJWT_|DATABASE_|MESSAGING_|HTTP_|AUTHENTICATION_|IMAGE_|JWT_|MAC_|NGINX_|FRAMEGRABS_|MEDIA_|SSL_|SQLSERVER_)' | sort
    )
    echo "# ------------------------------------------------------"
}

_run() {
    load_env

    local script_name=$(basename -- "$1")
    local script_ext="${script_name##*.}"

    if [ "$script_ext" = "py" ]; then
        python "$BASE_DIR/etc/python/$1" "${@:2}"
        return
    elif [ "$script_ext" = "sc" ]; then
        export VARS_PWD="$VARS_KB_DATABASE_PASSWORD"
        "$BASE_DIR/etc/scala/$1" "${@:2}"
        return
    else
        print_error "Unsupported script type: .$script_ext (expected .py or .sc)"
        return 1
    fi

}

_scripts() {
    local python_dir="$BASE_DIR/etc/python"
    local scala_dir="$BASE_DIR/etc/scala"
    local found=0

    print_info "Available scripts for './varsq run <script>':"
    echo ""

    # List Python scripts
    if [ -d "$python_dir" ]; then
        local py_scripts
        py_scripts=$(find "$python_dir" -maxdepth 1 -name "*.py" -type f 2>/dev/null | sort)
        if [ -n "$py_scripts" ]; then
            print_info "Python scripts (etc/python/):"
            while IFS= read -r script; do
                echo "  -  $(basename "$script")"
            done <<< "$py_scripts"
            echo ""
            found=1
        fi
    fi

    # List Scala scripts
    if [ -d "$scala_dir" ]; then
        local sc_scripts
        sc_scripts=$(find "$scala_dir" -maxdepth 1 -name "*.sc" -type f 2>/dev/null | sort)
        if [ -n "$sc_scripts" ]; then
            print_info "Scala scripts (etc/scala/):"
            while IFS= read -r script; do
                echo "  -  $(basename "$script")"
            done <<< "$sc_scripts"
            echo ""
            found=1
        fi
    fi

    if [ $found -eq 0 ]; then
        print_warning "No scripts found."
        print_info "  Python scripts should be placed in: $python_dir"
        print_info "  Scala scripts should be placed in: $scala_dir"
    fi
}

_start() {
    load_env
    print_info "Starting service using docker compose..."
    print_info "    Using environment file at $ENV_FILE"
    print_info "    Using temp dir at $M3_TEMP_DIR"
    print_info "    Ensuring SSL certificate and key exist at ${SSL_CERT_FILE} and ${SSL_KEY_FILE}..."
    if [ ! -f "${SSL_CERT_FILE}" ] || [ ! -f "${SSL_KEY_FILE}" ]; then
        print_error "SSL certificate or key not found. Run 'varsq mkcert' to generate self-signed certificate and key for localhost testing."
        exit 1
    fi
    _docker up -d "$@"
}

_stop() {
    load_env
    print_info "Stopping service using docker compose..."
    _docker down "$@"
}

_status() {
    load_env
    print_info "Checking status..."
    _docker ps "$@"
}

_targets() {
        print_info "Available environment targets:"
    echo ""
    for f in "${ETC_ENV_DIR}"/*.env; do
        if [[ -f "$f" ]]; then
            target=$(basename "$f" .env)
            echo "  - $target"
        fi
    done
    echo ""
    print_info "Configure with: $(basename "$0") configure <target>"
}

_update() {
    print_info "Updating docker images..."
    # The original script just echoed, but this actually runs the pulls
    docker pull mbari/annosaurus
    docker pull mbari/beholder
    docker pull mbari/charybdis
    docker pull mbari/oni
    docker pull mbari/panoptes
    docker pull mbari/raziel
    docker pull mbari/skimmer
    docker pull mbari/vampire-squid
    docker pull nginx:latest
    docker pull prom/prometheus
}

# Main logic
# Check if the first argument is empty or a help flag
if [[ -z "$1" ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    _help
    exit 0
fi

# Store the subcommand and shift arguments to the left
SUBCOMMAND=$1
shift

# Case statement to handle subcommands
case "$SUBCOMMAND" in
    build)
        _build "$@"
        ;;
    configure)
        _configure "$@"
        ;;
    docker)
        _docker "$@"
        ;;
    env)
        _env "$@"
        ;;
    mkcert)
        _mkcert "$@"
        ;;
    resolved)
        _resolved "$@"
        ;;
    run)
        _run "$@"
        ;;
    scripts)
        _scripts "$@"
        ;;
    start)
        _start "$@"
        ;;
    stop)
        _stop "$@"
        ;;
    status)
        _status "$@"
        ;;
    targets)
        _targets "$@"
        ;;
    update)
        _update "$@"
        ;;
    *)
        echo "Error: Unknown subcommand '$SUBCOMMAND'" >&2
        _help
        exit 1
        ;;
esac
